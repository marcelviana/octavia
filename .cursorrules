# üéµ Octavia Music Management - Enhanced Cursor Rules
# This file enhances your existing .cursorrules with specific workflows

# üèóÔ∏è PROJECT ARCHITECTURE
## Tech Stack
- Next.js 15 (App Router)
- Firebase Auth + Supabase Database
- TypeScript + Tailwind CSS + Radix UI
- Vitest + Playwright for testing

## Key Directories
- `/app` - Next.js app router pages and API routes
- `/components` - React components (UI + business logic)
- `/lib` - Utilities, services, and configurations
- `/hooks` - Custom React hooks
- `/contexts` - React context providers
- `/types` - TypeScript type definitions

# üîí SECURITY-FIRST DEVELOPMENT
## Authentication Pattern (MANDATORY)
```typescript
// ALL API routes must follow this pattern:
import { requireAuthServer } from '@/lib/firebase-server-utils';
import { getSupabaseServiceClient } from '@/lib/supabase-service';
import { z } from 'zod';

export async function POST(request: NextRequest) {
  // 1. Auth validation
  const user = await requireAuthServer(request);
  if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  
  // 2. Input validation
  const schema = z.object({ /* define schema */ });
  const validatedData = schema.parse(await request.json());
  
  // 3. Database operation with service role
  const supabase = getSupabaseServiceClient();
  // ... rest of logic
}
```

## Input Validation (REQUIRED)
- ALL user inputs must use Zod validation
- Never trust client-side data
- Sanitize all string inputs

## Error Handling (REQUIRED)
- Generic error messages only
- Log detailed errors server-side
- Never expose stack traces to users

# üß™ TESTING REQUIREMENTS
## Test Coverage Target: 85%
- Unit tests for all utilities and hooks
- Component tests for UI logic
- Integration tests for API routes
- E2E tests for critical user flows

## Test File Patterns
- `*.test.{ts,tsx}` - Unit tests
- `*.integration.test.{ts,tsx}` - Integration tests
- `/e2e/*.spec.ts` - Playwright E2E tests

# üé® CODE STYLE GUIDELINES
## Component Architecture
- Extract business logic into custom hooks
- Keep components focused and small (<150 lines)
- Use TypeScript interfaces for all props
- Implement proper error boundaries

## Performance Rules
- Use React.memo for expensive components
- Implement lazy loading for routes
- Optimize images with Next.js Image component
- Use proper loading states

# üîÑ DEVELOPMENT WORKFLOWS

## When creating new components:
1. Generate TypeScript interface first
2. Create component with proper error handling
3. Extract business logic to custom hook
4. Write comprehensive tests
5. Add accessibility attributes

## When creating API routes:
1. Implement authentication check
2. Add Zod input validation
3. Use proper error handling
4. Write integration tests
5. Add rate limiting if needed

## When refactoring:
1. Maintain backward compatibility
2. Update all related tests
3. Check TypeScript errors
4. Verify security implications
5. Update documentation

# üìä SPECIFIC PROJECT PATTERNS

## Content Management Pattern
```typescript
// Use this pattern for content CRUD operations
const useContentManagement = () => {
  const { user } = useFirebaseAuth();
  const [loading, setLoading] = useState(false);
  
  const createContent = async (data: ContentInput) => {
    setLoading(true);
    try {
      // Call API with proper error handling
    } finally {
      setLoading(false);
    }
  };
  
  return { createContent, loading };
};
```

## Database Service Pattern
```typescript
// All Supabase operations must use service client
export async function getUserContent(userId: string) {
  const supabase = getSupabaseServiceClient();
  
  const { data, error } = await supabase
    .from('content')
    .select('*')
    .eq('user_id', userId);
    
  if (error) throw new DatabaseError('Failed to fetch content');
  return data;
}
```

# üéØ CURSOR-SPECIFIC INSTRUCTIONS

## For Code Generation:
- Always generate complete, working code
- Include proper TypeScript types
- Add comprehensive error handling
- Include relevant tests
- Follow the security patterns above

## For Refactoring:
- Maintain existing functionality
- Improve type safety
- Extract reusable logic
- Add missing tests
- Optimize performance

## For Debugging:
- Check authentication flow first
- Verify input validation
- Review error handling
- Test edge cases
- Check accessibility

# üöÄ QUICK COMMANDS FOR CURSOR

## Generate Component:
"Create a new React component with TypeScript, proper error handling, and tests"

## Secure API Route:
"Create an API route with Firebase auth, Zod validation, and proper error handling"

## Refactor Component:
"Refactor this component to extract business logic into a custom hook and improve performance"

## Add Tests:
"Generate comprehensive tests for this component including unit and integration tests"

## Security Review:
"Review this code for security issues and improve input validation and error handling"

# üîç CODE REVIEW CHECKLIST

Before accepting any generated code, verify:
- [ ] Authentication is properly implemented
- [ ] Input validation uses Zod schemas
- [ ] Error handling is secure and generic
- [ ] TypeScript types are comprehensive
- [ ] Tests cover main functionality
- [ ] Performance optimizations are applied
- [ ] Accessibility is considered
- [ ] Security best practices followed